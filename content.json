[{"title":"JS--获取验证码","date":"2018-03-22T15:53:18.000Z","path":"/posts/38c9e2c9/","text":"JS–获取验证码 let str=”abcdefghigklmnopqrstuvwxyz”+”0123456789”+”abcdefghigklmnopqrstuvwxyz”.toLocaleUpperCase(); let code=document.getElementById(“code”); let chang=document.getElementById(“chang”); function ff() { let s=””; for (let i=0;i&lt;4;i++){ let b=Math.round(Math.random()*61); s+=str[b]; code.innerHTML=s; }} chang.onclick=ff","tags":[]},{"title":"JS--原型继承","date":"2018-03-22T15:49:46.000Z","path":"/posts/82ffdd24/","text":"JS–原型继承 function A() { this.a=”a” } A.prototype.getA=function () { console.log(this.a); } function B() { this.b=”b” } B.prototype.getB=function () { console.log(this.b); }; A的原型等于B的实例 A.prototype=new B():这个可以获取B的实例的私有属性b,也可以通过proto得到B的原型上的公有方法getB 弊端：A.prototype原来的属性和方法就没了 A.prototype=new B(); Object.assign(A.prototype,new B) 既保留了A.prototype原来的方法和属性，还可以拿到B的实例的私有属性 弊端：获取不到B的原型上的公有属性和方法 Object.assign(A.prototype,new B); 综上所述，结合自己写的方法，即实现了合并对象也实现了获取原型上的公有方法 assign(A.prototype,new B) var a=new A; var b=new B; console.log(a); 合并对象 Object.assign(obj1,obj2) 将obj2合并到obj1 合并对象只能拿到私有的，不能拿到公有的 function assign(obj1,obj2) { 将obj2的私有属性给obj1，当做私有属性，将obj2的公有属性给obj1,当做公有属性 for(var key in obj2){ if(obj2.hasOwnProperty(key)){ obj1[key]=obj2[key]; }else { obj1.proto[key]=obj2[key] } } }","tags":[]},{"title":"JS--Url地址解析方法","date":"2018-03-22T15:04:53.000Z","path":"/posts/11e73ae9/","text":"JS–Url地址解析方法 function fn1(url) { var ary=url.split(“?”)[1].split(“&amp;”); //[‘course1=ss’,’course2=css’,’course3=jQ’] var obj={}; ary.forEach(function (item) { var a=item.split(“=”); obj[a[0]]=a[1]; }); return obj } 方法二: function fn2(url) { var ary=url.split(/[?&amp;=]/g); ary.shift(); var obj={}; for(var i=0;i&lt;ary.length;i+=2){ obj[ary[i]]=ary[i+1]; } return obj } 方法三: function fn3(url) { //“{course1:’ss’,course2:’css’,course3:’jQ’}” //“ course1= ss &amp;course2=css &amp;course3=jQ “ //= -&gt; :’ //&amp; -&gt; ‘, url=url.split(“?”)[1]; var str=url.replace(/=/g,”:’”).replace(/&amp;/g,”‘,”); str=”({“+str+”‘})”; return eval(str); //可以将上面的简写成下面的 return eval(“({“+ url.split(“?”)[1].replace(/=/g,”:’”).replace(/&amp;/g,”‘,”)+”‘})”); } console.log(fn3(url)); 方法四: function fn4(url) { var reg=/?&amp;=(\\w+)/g; var obj={}; url.replace(reg,function () { obj[arguments[1]]=arguments[2] }); return obj } console.log(fn4(url)); 方法5: function fn5(url) { return eval(“({“+url.split(“?”)[1].replace(/&amp;?(\\w+)=(\\w+)/g, “$1:’$2’,”)+”})”); } function num(url) { let sum=url.indexOf(“?”), obj={}; if(sum===-1){ return obj } url=url.substr(sum+1); var ary=url.split(“&amp;”); for (var i = 0; i &lt; ary.length; i++) { let cur=ary[i].split(“=”); obj[cur[0]]=cur[1] } return obj;}console.log(num(str)); String.prototype.sum=function sum () { let obj={}; let reg=/([^?=&amp;]+)=([^?=&amp;]+)/g; this.replace(reg,function () { let arr=arguments; obj[arr[1]]=arr[2] }); return obj};console.log(str.sum()); var obj={};var sum=str.indexOf(“?”);str=str.substring(sum+1);var ary=str.split(“&amp;”);for (var i = 0; i &lt; ary.length; i++) { var cur=ary[i]; var curAry=cur.split(“=”), key=curAry[0], value=curAry[1]; obj[key]=value;}console.log(obj);","tags":[]},{"title":"JS--Call继承","date":"2018-03-22T15:02:07.000Z","path":"/posts/683ebf7b/","text":"JS–Call继承 Function.prototype.call=function () { this 表示的是实例 f1 把arguments变成数组 var ary=[…arguments]; if(ary[0]==undefined){ 没传，null，undefined 让this执行里面的this变成window ary.shift(); eval(“this(“+ary+”)”); }else { //将传进来的参数变成一个对象 var obj=Object(arguments[0]); 给obj所属类的原型上增加一个属性，属性值就是this obj.proto.fn=this; ary.shift(); eval(“obj.fn(“+ary+”)”); 将增加的属性删除 delete obj.proto.fn; } }; var obj={a:1}; function f1(m,n) { console.log(this); console.log(m,n); } f1.call(obj,2,5); Object方法，将你传进来的东西变成一个对象返回 Function.prototype.call=function(){var ary=[…arguments];ary.shift(); if(arguments[0]==undefined){ this(…ary); //展开里面的每一项 return; } var obj=Object(arguments[0]); obj.fn=this; this(…ary); delete obj.fn }","tags":[]},{"title":"JS--原型上的数组去重","date":"2018-03-22T14:57:42.000Z","path":"/posts/97809bdb/","text":"JS–原型上的数组去重 Array.prototype.remove = function () { for (var i = 0; i &lt; this.length; i++) { if (this.indexOf(this[i]) !== this.lastIndexOf(this[i])) { this.splice(i, 1); i–; } } return this;};console.log([1, 1, 2, 2, 2, 5, 5, 5, 4, 1, 2, 3].remove()); Array.prototype.remove=function () { this==实例 var _this=this; return this.filter(function (item,index) { this==window return !_this.slice(0,index).includes(item) })};console.log([1, 1, 1, 1, 2, 2].remove()); 利用对象的属性名不可以重复来实现数组去重 Array.prototype.remove=function () { var obj={},ary=[]; this.forEach(function (item) { obj[item]=item; }) for (var key in obj){ key是字符串 ary.push(obj[key]) } return ary; }","tags":[]},{"title":"JS--数组方法整理","date":"2018-03-22T14:54:02.000Z","path":"/posts/75415fbc/","text":"JS–数组方法整理 “use strict”; 严格模式 function f1() { console.log(this); } f1.call(null); this -&gt;null f1.call(); this –&gt;undefined f1.call(undefined); this –&gt;undefined 在严格模式下函数执行前面没有点this就是undefined f1(); console.log(window.f1()); 类数组转数组: function ff() { var ary=[…arguments]; return ary; } console.log(ff(1, 2, 3)); function ff(item) { var ary=[]; for (var i=0;i&lt;item.length;i++){ ary.push(item[i]); } return ary } function sum() { return ff(arguments) } console.log(sum(1, 2, 3)); 通过原型上的方法: function ff(a) { return Array.prototype.slice.call(a); } function sum() { return ff(arguments) } console.log(sum(7, 8, 9)); 检测数据额类型: console.log(typeof (1)); function sum(fn) { return fn.constructor.name; return Array.prototype.toString.call(fn) } console.log(sum(1, 2, 3)); var obj={a:”哈哈”,b:12}; var aa=new Object; console.log(obj instanceof Object); 最大值: var ary=[1,2,3,5,6,7,8]; function sum() { return Math.max.apply(null,ary) } console.log(sum()); function ff() { return eval(“Math.max(“+ary+”)”) } console.log(ff()); json: var dataObj=[{“a”:”哈哈”,”b”:12}]; var dataStr=’[{“name”:”a”,”age”:2},{“name”:”b”,”age”:12},{“name”:”c”,”age”:22},{“name”:”d”,”age”:32}]’; 对象转字符串: console.log(JSON.stringify(dataObj)); 将字符串转对象: console.log(JSON.stringify(dataStr)); var s=’{“name”:”a”,”age”:12}’; console.log(eval(“(“ + s + “)”)); var ff=Function(“return”+s); console.log(ff()); var ary=[1,2,5,1,5,5,6,8,6,2,1]; Array.prototype.remove=function () { var ary1=[]; for(var i=0;i&lt;ary.length;i++){ if(!ary1.includes(ary[i])){ ary1.push(ary[i]) } } return ary1 }; console.log(ary.remove()); 数组去重: Array.prototype.remove = function () { this==实例 for(var i=0;i&lt;this.length;i++){ if(this.indexOf(this[i])!==this.lastIndexOf(this[i])){ this.splice(i,1); i–; } } return this; }; console.log(ary.remove()); Array.prototype.remove=function () { var a=this; return this.filter(function (item,index) { return !a.slice(0,index).includes(item) }) }; console.log(ary.remove()); var ary=[1,2,3,1,4,1,5,1,8,5,4,1,1]; function fn(ary) { return [Array.from(new Set(ary))]; } console.log(fn(ary)); function fn(ary) { return […new Set(ary)]; } console.log(fn(ary)); 数组排序： function mySort() { var tags=new Array(); tags=Array.prototype.slice.call(arguments); tags.sort(function (a,b) { return a-b }); return tags;} console.log(mySort(50, 11, 16, 32, 24, 99, 57, 100));","tags":[]},{"title":"JS--数组求和","date":"2018-03-22T14:45:54.000Z","path":"/posts/ad68a086/","text":"JS–数组求和 var ary1=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,37,38,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,75,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100];var ary2=[];for(var i=0;i&lt;100;i++){ if(i%7===0){ ary2.push(ary1[i]); }} console.log(ary2); var ary1=ary2.join(“+”); console.log(ary1); var ary3=eval(ary1); console.log(ary3); function sum() { var a=0; for(var i=0;i&lt;arguments.length;i++){ if(!isNaN(arguments[i])){ a+=arguments[i] } } return a} console.log(sum(11, 22, 33)); function ff() { var a=0; for(var i=0;i&lt;arguments.length;i++){ a+=arguments[i]; } return a} console.log(ff(11, 2, 2, 20)); function fn() { var arguments=[].slice.call(arguments); for(var i=0;i&lt;arguments.length;i++){ return eval(“(“+arguments.join(“+”)+”)”) }} console.log(fn(11, 22, 66));","tags":[]},{"title":"JS--数组中回调函数原理","date":"2018-03-22T14:43:34.000Z","path":"/posts/47e14251/","text":"JS–数组中回调函数原理 函数当做参数，叫做回调函数 例如：数组中的很多方法，是传进去一个函数去执行的 var ary=[1,2,3,5,6]; 第一个参数是一个函数，第二个参数是改变前面函数this的 Array.prototype.forEach(function (fn,obj) { this表示 数组实例 循环数组让函数fn，依次执行执行的时候通过call改变fn的this，给fn传三个参数，（当前项this[i],i索引，this，原数组this） for(var i=0;i&lt;this.length;i++){ fn.call(obj,this[i],i,this) } }); ary.forEach(function (item,index,input) { 不需要返回值 第二个参数是改变前面函数this console.log(this); },ary) Array.prototype.map=function (fn,obj) { 循环数组让函数fn，依次执行执行的时候通过call改变fn的this，给fn传三个参数， （当前项this[i],i索引，this，原数组this），将返回值push到ary中 有返回值，返回值：fn每次执行的结果组成的新数组， var ary=[]; for(var i=0;i&lt;this.length;i++){ ary.push(fn.call(obj,this[i],i,this)) } return ary; } var a=ary.map(function (item,index,input) { return item+index }) console.log(a); Array.position.find=function (fn,obj) { 循环数组让函数fn，依次执行执行的时候通过call改变fn的this，给fn传三个参数， （当前项this[i],i索引，this，原数组this)一直到fn的返回值是turn的时候停止循环，返回当前项this[i] for (var i=0;i&lt;this.length;i++){ if(fn.call(obj,this[i],i,input)){ return this[i]; 返回当前项 } } }; var a=Array.prototype.find=(function (item,index,input) { 找到的结果为turn，就返回当前项 console.log(item); return item===3; }); console.log(a); Array.position.findIndex=function (fn,obj) { 循环数组让函数fn，依次执行执行的时候通过call改变fn的this，给fn传三个参数， （当前项this[i],i索引，this，原数组this)一直到fn的返回值是turn的时候停止循环，返回当前项索引[i] for (var i=0;i3 }); console.log(a);","tags":[]},{"title":"JS--数组中的方法","date":"2018-03-22T14:37:50.000Z","path":"/posts/dd2140a1/","text":"JS–数组中的方法 var a=[1,2,3];Array.prototype.unshift=function () { var str=””;var ary=null; for(var i=0;i&lt;arguments.length;i++){ str+=arguments[i]+”,”; } ary=eval(“[“+str+this+”]”); for(var k=0;k&lt;ary.length;k++){ this[k]=ary[k] } return ary.length;}; console.log(a.unshift(20, 3)); console.log(a); Array.prototype.push=function () { for(var i=0;i&lt;arguments.length;i++){ this[this.length]=arguments[i]; } return this.length; } console.log(a.push(8, 9)); console.log(a); Array.prototype.pop=function () { var num=this[this.length-1]; this.length–; return num; } console.log(a.pop()); console.log(a); Array.prototype.shift=function () { var num=this[0]; for(var i=1;i&lt;this.length;i++){ this[i-1]=this[i]; } this.length–; return num} console.log(a.shift()); console.log(a);","tags":[]},{"title":"JS--数组去重","date":"2018-03-22T14:29:47.000Z","path":"/posts/cc0665b2/","text":"JS–数组去重 let ary1=[1,2,1,2,1,23,4,1,23,24,4,5,2,3,6,7]; function ff(item) { var ary=[]; for(var i=0;i&lt;ary1.length;i++){ if(!ary.includes(item[i])){ ary.push(item[i]) } } return ary } console.log(ff(ary1)); var ary2=ary1.filter(function (item,index) { return !ary1.slice(0,index).includes(item) }); console.log(ary2); for(var i=0;i&lt;ary1.length;i++){ if(ary1.indexOf(ary1[i])==!ary1.lastIndexOf(ary1[i])){ ary1.splice(i,1); i–; } } console.log(ary1); Array.prototype.remove=function () { var obj={},ary=[]; this.forEach(function (item) { obj[item]=item; }) for(var key in obj){ ary.push(obj[key]) } return ary;}console.log([1,1,1,2,2,2,3,5,5,5,6,8,8,9].remove());","tags":[]},{"title":"Hello World","date":"2018-03-22T13:48:37.962Z","path":"/posts/16107/","text":"","tags":[]}]